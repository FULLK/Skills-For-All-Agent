python3 ./example.py 


> Entering new AgentExecutor chain...

Invoking: `skill_tool` with `{'payload': {'action': 'list_metadata', 'arg': '/root/LLK/skills_for_all_agent/skills_for_all_agent/skills'}}`


/root/LLK/skills_for_all_agent/skills_for_all_agent/skills/c_2_ast
{
  "ok": true,
  "skills": [
    {
      "name": "c-to-ast",
      "description": "Parse C source code into an Abstract Syntax Tree (AST). Use when analyzing C programs, understanding code structure, performing static analysis, or preparing code for further program analysis (e.g., CFG, DFG, vulnerability detection).",
      "path": "/root/LLK/skills_for_all_agent/skills_for_all_agent/skills/c_2_ast"
    }
  ],
  "prompt": "## Skills\n- c-to-ast: Parse C source code into an Abstract Syntax Tree (AST). Use when analyzing C programs, understanding code structure, performing static analysis, or preparing code for further program analysis (e.g., CFG, DFG, vulnerability detection)."
}
Invoking: `skill_tool` with `{'payload': {'action': 'read_file', 'arg': '/root/LLK/skills_for_all_agent/skills_for_all_agent/skills/c_2_ast/SKILL.md'}}`


{
  "ok": true,
  "content": "---\nname: c-to-ast\ndescription: Parse C source code into an Abstract Syntax Tree (AST). Use when analyzing C programs, understanding code structure, performing static analysis, or preparing code for further program analysis (e.g., CFG, DFG, vulnerability detection).\n---\n\n# C to AST Skill\n\n## Purpose\n\nThis Skill converts **C source code** into its **Abstract Syntax Tree (AST)** representation.\n\nUse this Skill when you need to:\n- Understand the structure of a C program\n- Analyze functions, statements, and expressions\n- Prepare C code for static analysis or security analysis\n- Transform C code into an intermediate representation (AST)\n- Feed structured code information into downstream tools or agents\n\nThe AST is generated using a Python-based C parser and printed directly to standard output.\n\n---\n\n## When to Use\n\nApply this Skill when the user asks to:\n- â€œParse this C codeâ€\n- â€œConvert this C file to an ASTâ€\n- â€œShow me the AST of this C programâ€\n- â€œAnalyze the structure of this C codeâ€\n- â€œExtract syntax tree / abstract syntax tree from Câ€\n\nThis Skill is especially useful in **compiler frontends**, **program analysis**, and **security research** workflows.\n\n---\n\n## Instructions\n\nFollow these steps strictly and in order:\n\n1. **Navigate to the Skill scripts directory**\n   - Change working directory to:\n     ```\n     skills_for_all_agent/skill/c_2_ast/scripts/\n     ```\n\n2. **Handle the input C source**\n   - If the user provides a **path to a `.c` file**, use it directly.\n   - If the user provides **inline C code as a string**, you must first save it to a C source file using the provided script:\n     ```bash\n     python3 save_c.py --input \"<C code string>\" --output <output_dir> --filename <filename>.c\n     ```\n   - Ensure the generated file has a `.c` extension and is successfully written to disk.\n\n3. **Run the AST extraction script**\n   - Convert the C source file to its Abstract Syntax Tree by executing:\n     ```bash\n     python3 c_2_ast.py --input <path_to_c_file>\n     ```\n\n4. **Do not modify the source code**\n   - This Skill is strictly read-only.\n   - Do not rewrite, reformat, optimize, or otherwise alter the C code.\n\n5. **Return the AST output verbatim**\n   - The script prints the AST directly to standard output.\n   - Return the output exactly as produced.\n   - Do not summarize, paraphrase, or restructure the AST.\n   - Preserve indentation, hierarchy, and node ordering.\n\n6. **If parsing fails**\n   - Report the exact error message produced by the script.\n   - Suggest likely causes, such as:\n     - Missing or unsupported header files\n     - Unsupported C extensions (e.g., compiler-specific syntax)\n     - Invalid or incomplete C syntax\n\n---\n\n## Output Format\n\nThe output is a **tree-structured textual AST**, for example:\n\n````\n\nFileAST:\nFuncDef:\nDecl: main\nFuncDecl:\nTypeDecl:\nIdentifierType: ['int']\nCompound:\nFuncCall:\nID: puts\nExprList:\nConstant: string, \"Hello\"\nReturn:\nConstant: int, 0\n\n````\n\nThis output represents the syntactic structure of the C program and can be consumed by downstream tools.\n\n---\n\n## Additional Resources\n\nFor deeper understanding of:\n- AST node types\n- `pycparser` internal representation\n- Meaning of specific syntax tree nodes\n- Limitations of the C grammar supported\n\nsee the accompanying reference document:\n\nâ¡ï¸ **[reference.md](reference.md)**\n\nOnly read this file **when more detailed or theoretical information is required**.  \nFor standard AST extraction tasks, this Skill file alone is sufficient.\n\n---\n\n## Notes and Limitations\n\n- The AST follows standard C syntax (C89/C99 subset).\n- Some compiler-specific extensions (e.g., GCC attributes) may not be supported.\n- Header files are handled using a minimal fake libc environment.\n- Macro-heavy or highly platform-specific code may require preprocessing.\n\n---\n\n## Examples\n\n### Example 1: Simple AST extraction\n\nUser request:\n> Convert this C file to an AST.\n\nAction:\n```bash\npython3 c_2_AST.py --input example.c\n````\n\nResult:\n\n* The AST is printed directly.\n\n---\n\n### Example 2: Security analysis preparation\n\nUser request:\n\n> I want to analyze this C program for vulnerabilities.\n\nAction:\n\n* First, extract the AST using this Skill.\n* Then, pass the AST to a vulnerability analysis or pattern-matching process.\n\n---\n\n## Best Practices\n\n* Use this Skill **before** any deep code analysis.\n* Treat the AST as an intermediate representation.\n* Combine with CFG/DFG or semantic analysis for advanced tasks.\n\n---\n\nEnd of Skill.\n"
}
Invoking: `skill_tool` with `{'payload': {'action': 'read_file', 'arg': '/root/LLK/skills_for_all_agent/skills_for_all_agent/skills/c_2_ast/reference.md'}}`


{
  "ok": true,
  "content": "# reference.md\n\n## C Abstract Syntax Tree (AST) Reference\n\nThis document provides **detailed reference material** for understanding the **Abstract Syntax Tree (AST)** generated from C source code by the `c_2_AST.py` script.\n\nRead this file **only when deeper knowledge is required**, such as:\n\n* Interpreting specific AST node types\n* Writing AST-based analyses or transformations\n* Performing vulnerability detection or code pattern matching\n* Mapping syntax to semantic structures (CFG / DFG)\n\n---\n\n## 1. What Is a C AST?\n\nAn **Abstract Syntax Tree (AST)** is a hierarchical representation of a programâ€™s syntactic structure.\n\nKey properties:\n\n* Represents **syntax**, not runtime behavior\n* Ignores formatting, comments, and whitespace\n* Encodes structure: declarations, statements, expressions\n\nASTs are commonly used in:\n\n* Compilers and interpreters\n* Static analysis tools\n* Security auditing and vulnerability detection\n* Program understanding and refactoring tools\n\n---\n\n## 2. AST Format Used in This Skill\n\nThis Skill uses **`pycparser`**, a pure-Python C parser that supports a large subset of ISO C.\n\nThe AST is represented as a tree of Python objects, printed in a readable textual format using:\n\n```python\nast.show()\n```\n\nThe root node is always:\n\n```\nFileAST\n```\n\n---\n\n## 3. High-Level AST Structure\n\n```\nFileAST\n â”œâ”€â”€ Decl\n â”œâ”€â”€ FuncDef\n â”‚    â”œâ”€â”€ Decl\n â”‚    â”œâ”€â”€ ParamList\n â”‚    â””â”€â”€ Compound\n â””â”€â”€ ...\n```\n\n* `FileAST`: Entire translation unit\n* Each child corresponds to a **top-level declaration or definition**\n\n---\n\n## 4. Core Node Types (Most Important)\n\n### 4.1 FileAST\n\n**Root node** of the AST.\n\n```text\nFileAST:\n  ext[0]: FuncDef\n  ext[1]: Decl\n```\n\nContains:\n\n* Global variable declarations\n* Function definitions\n* Type definitions\n\n---\n\n### 4.2 FuncDef (Function Definition)\n\nRepresents a full function definition.\n\n```text\nFuncDef:\n  Decl: main\n  ParamList\n  Compound\n```\n\nComponents:\n\n* `Decl`: function signature\n* `ParamList`: parameters (may be empty)\n* `Compound`: function body\n\n---\n\n### 4.3 Decl (Declaration)\n\nUsed for:\n\n* Variables\n* Functions\n* Parameters\n\n```text\nDecl: x\n  TypeDecl\n  Constant\n```\n\nKey attributes:\n\n* `name`: identifier\n* `type`: declared type\n* `init`: initializer (if any)\n\n---\n\n### 4.4 Type Nodes\n\nType information is represented hierarchically.\n\n#### TypeDecl\n\n```text\nTypeDecl:\n  IdentifierType: ['int']\n```\n\n#### PtrDecl\n\n```text\nPtrDecl:\n  TypeDecl\n```\n\n#### ArrayDecl\n\n```text\nArrayDecl:\n  TypeDecl\n  Constant\n```\n\n---\n\n### 4.5 Compound (Block)\n\nRepresents a `{ ... }` block.\n\n```text\nCompound:\n  Decl\n  Assignment\n  Return\n```\n\nUsed for:\n\n* Function bodies\n* Control-flow blocks\n\n---\n\n## 5. Statement Nodes\n\n### 5.1 Assignment\n\n```text\nAssignment:\n  ID: x\n  BinaryOp: +\n```\n\nRepresents:\n\n```c\nx = a + b;\n```\n\n---\n\n### 5.2 Return\n\n```text\nReturn:\n  Constant: int, 0\n```\n\nRepresents:\n\n```c\nreturn 0;\n```\n\n---\n\n### 5.3 If\n\n```text\nIf:\n  BinaryOp\n  Compound\n  Compound\n```\n\nRepresents:\n\n```c\nif (cond) { ... } else { ... }\n```\n\n---\n\n### 5.4 While / For\n\n```text\nWhile:\n  BinaryOp\n  Compound\n```\n\n```text\nFor:\n  Assignment\n  BinaryOp\n  Assignment\n  Compound\n```\n\n---\n\n## 6. Expression Nodes\n\n### 6.1 ID\n\n```text\nID: x\n```\n\nVariable reference.\n\n---\n\n### 6.2 Constant\n\n```text\nConstant: int, 42\nConstant: string, \"hello\"\n```\n\nLiteral values.\n\n---\n\n### 6.3 BinaryOp\n\n```text\nBinaryOp: +\n  ID: a\n  ID: b\n```\n\nRepresents:\n\n```c\na + b\n```\n\nOperators include:\n`+ - * / % < > == != && ||`\n\n---\n\n### 6.4 FuncCall\n\n```text\nFuncCall:\n  ID: puts\n  ExprList\n```\n\nRepresents:\n\n```c\nputs(\"hello\");\n```\n\n---\n\n## 7. Common Patterns (Analysis-Oriented)\n\n### Function Call Detection\n\nLook for:\n\n```\nFuncCall â†’ ID(name)\n```\n\nUseful for:\n\n* Detecting dangerous functions (`gets`, `strcpy`)\n* API usage analysis\n\n---\n\n### Control Flow Detection\n\nLook for:\n\n* `If`\n* `For`\n* `While`\n* `Switch`\n\nThese nodes form the basis of **CFG construction**.\n\n---\n\n### Memory-Related Operations\n\nRelevant nodes:\n\n* `FuncCall` to `malloc`, `free`\n* Pointer `PtrDecl`\n* Dereference via `UnaryOp: *`\n\n---\n\n## 8. Limitations and Caveats\n\n* Supports **standard C**, not full GCC extensions\n* Macro-heavy code may be simplified by preprocessing\n* No semantic analysis (types are syntactic, not resolved)\n* No symbol resolution across files\n\nFor complex builds, preprocessing quality matters.\n\n---\n\n## 9. Typical Downstream Uses\n\nASTs extracted by this Skill are commonly used for:\n\n* Building **Control Flow Graphs (CFG)**\n* Extracting **Data Flow Graphs (DFG)**\n* Pattern-based vulnerability detection\n* Code similarity and embedding\n* Automated refactoring and transformation\n\n---\n\n## 10. Summary\n\n* AST = **structured syntax representation**\n* `FileAST` is always the root\n* Nodes map closely to C language constructs\n* Ideal intermediate form for static analysis and security research\n\nUse this reference as a **lookup guide**, not as required reading for every task.\n\n---\n\nEnd of reference.\n"
}


ä½ å¸Œæœ›éå¸¸æ·±å…¥åœ°äº†è§£ **ASTï¼ˆAbstract Syntax Treeï¼ŒæŠ½è±¡è¯­æ³•æ ‘ï¼‰**ï¼Œè¿™æ˜¯ä¸€ä¸ªéå¸¸é‡è¦ä¸”åŸºç¡€çš„è®¡ç®—æœºç§‘å­¦æ¦‚å¿µï¼Œå°¤å…¶åœ¨ç¼–è¯‘å™¨è®¾è®¡ã€ç¨‹åºåˆ†æã€ä»£ç å®‰å…¨ã€é‡æ„å·¥å…·ç­‰é¢†åŸŸå…·æœ‰æ ¸å¿ƒåœ°ä½ã€‚

æ ¹æ®æˆ‘ä»¬ç›®å‰æ¢ç´¢åˆ°çš„å†…å®¹ï¼ˆç‰¹åˆ«æ˜¯ `c_2_ast` æŠ€èƒ½åŠå…¶é…å¥—çš„ `reference.md`ï¼‰ï¼Œæˆ‘å·²ç»ä¸ºä½ æ•´ç†äº†ä¸€ä»½**æ·±åº¦è§£æ AST çš„ç»“æ„åŒ–çŸ¥è¯†ä½“ç³»**ï¼Œæ¶µç›–ç†è®ºã€ç»“æ„ã€å®è·µå’Œåº”ç”¨ï¼š

---

## ğŸŒ² ä¸€ã€ä»€ä¹ˆæ˜¯ ASTï¼Ÿâ€”â€” æ ¸å¿ƒç†è®º

### 1. å®šä¹‰
**AST æ˜¯æºä»£ç è¯­æ³•ç»“æ„çš„æ ‘å½¢æŠ½è±¡è¡¨ç¤ºã€‚**
- å¿½ç•¥å…·ä½“å­—ç¬¦ï¼ˆå¦‚ç©ºæ ¼ã€æ³¨é‡Šã€åˆ†å·ï¼‰
- ä¿ç•™ç¨‹åºçš„**è¯­æ³•å±‚æ¬¡ä¸è¯­ä¹‰å…³ç³»**
- æ˜¯ç¼–è¯‘å™¨å‰ç«¯çš„æ ¸å¿ƒäº§ç‰©

### 2. ä¸ºä»€ä¹ˆéœ€è¦ ASTï¼Ÿ
- âœ… **ç»“æ„åŒ–è¡¨è¾¾**ï¼šå°†çº¿æ€§æ–‡æœ¬è½¬ä¸ºå¯éå†/åˆ†æçš„æ ‘
- âœ… **å¹³å°æ— å…³**ï¼šè„±ç¦»å…·ä½“ç¼–ç¨‹è¯­è¨€æ ¼å¼
- âœ… **ä¸­é—´è¡¨ç¤º**ï¼šç”¨äºåç»­ä¼˜åŒ–ã€è½¬æ¢ã€åˆ†æï¼ˆCFG/DFG/Vulnerability Detectionï¼‰
- âœ… **è‡ªåŠ¨åŒ–å¤„ç†**ï¼šæ”¯æŒé™æ€åˆ†æã€é‡æ„ã€ç¿»è¯‘ã€ç”Ÿæˆç­‰ä»»åŠ¡

### 3. AST vs Parse Tree
| ç‰¹æ€§ | Parse Tree (è¯­æ³•æ ‘) | AST (æŠ½è±¡è¯­æ³•æ ‘) |
|------|---------------------|------------------|
| åŒ…å«ç»†èŠ‚ | æ‰€æœ‰è¯­æ³•ç¬¦å·ï¼ˆæ‹¬å·ã€åˆ†å·ç­‰ï¼‰ | åªä¿ç•™å…³é”®ç»“æ„ |
| å±‚çº§æ·±åº¦ | æ›´æ·±ã€æ›´å†—ä½™ | æ›´æµ…ã€æ›´ç²¾ç®€ |
| åº”ç”¨åœºæ™¯ | è¯­æ³•æ•™å­¦ã€è°ƒè¯• | ç¼–è¯‘å™¨ã€åˆ†æå™¨ã€é‡æ„ |

> ğŸ’¡ AST æ˜¯ Parse Tree çš„â€œå‹ç¼©ç²¾åç‰ˆâ€

---

## ğŸ§± äºŒã€Cè¯­è¨€ AST ç»“æ„è¯¦è§£ï¼ˆåŸºäº `pycparser`ï¼‰

æˆ‘ä»¬ä½¿ç”¨çš„æŠ€èƒ½åº•å±‚ä¾èµ– [pycparser](https://github.com/eliben/pycparser)ï¼Œå®ƒæ”¯æŒ ISO C99 å­é›†ï¼Œè¾“å‡ºç»“æ„æ¸…æ™°ã€å±‚çº§æ˜ç¡®ã€‚

### 1. æ ¹èŠ‚ç‚¹ â€”â€” `FileAST`
ä»£è¡¨æ•´ä¸ªç¿»è¯‘å•å…ƒï¼ˆTranslation Unitï¼‰ï¼Œå³ä¸€ä¸ª `.c` æ–‡ä»¶ã€‚
```text
FileAST:
  FuncDef: main
  Decl: global_var
```

### 2. å‡½æ•°å®šä¹‰ â€”â€” `FuncDef`
```text
FuncDef:
  Decl: functionName
    TypeDecl: returnType
  ParamList: (å‚æ•°åˆ—è¡¨)
  Compound: {å‡½æ•°ä½“}
```

### 3. å£°æ˜èŠ‚ç‚¹ â€”â€” `Decl`
é€šç”¨å£°æ˜èŠ‚ç‚¹ï¼Œå¯ç”¨äºå˜é‡ã€å‡½æ•°ã€å‚æ•°ï¼š
```text
Decl: x
  TypeDecl: int
  init: Constant: 42
```

### 4. ç±»å‹ç³»ç»ŸèŠ‚ç‚¹
- `TypeDecl`: åŸºç¡€ç±»å‹ï¼ˆint, char...ï¼‰
- `PtrDecl`: æŒ‡é’ˆç±»å‹ `*`
- `ArrayDecl`: æ•°ç»„ç±»å‹ `[N]`
- `FuncDecl`: å‡½æ•°ç±»å‹ï¼ˆè¿”å›å€¼ + å‚æ•°ï¼‰

### 5. è¯­å¥å— â€”â€” `Compound`
å¯¹åº” `{}` åŒ…è£¹çš„å¤åˆè¯­å¥ï¼š
```text
Compound:
  Assignment
  If
  Return
```

### 6. è¡¨è¾¾å¼èŠ‚ç‚¹ï¼ˆé‡ç‚¹ï¼ï¼‰
#### â¤ `ID`: æ ‡è¯†ç¬¦å¼•ç”¨
```text
ID: variable_name
```

#### â¤ `Constant`: å­—é¢é‡
```text
Constant: int, 42
Constant: string, "hello"
```

#### â¤ `BinaryOp`: äºŒå…ƒæ“ä½œ
```text
BinaryOp: +
  ID: a
  ID: b
â†’ å¯¹åº” a + b
```

#### â¤ `FuncCall`: å‡½æ•°è°ƒç”¨
```text
FuncCall:
  ID: printf
  ExprList:
    Constant: string, "Hello"
â†’ å¯¹åº” printf("Hello");
```

#### â¤ `Assignment`: èµ‹å€¼è¯­å¥
```text
Assignment: =
  ID: x
  BinaryOp: *
    ID: y
    Constant: 2
â†’ å¯¹åº” x = y * 2;
```

#### â¤ `If / While / For`: æ§åˆ¶æµè¯­å¥
```text
If:
  BinaryOp: >
    ID: x
    Constant: 0
  Compound: { ... }   â† then åˆ†æ”¯
  Compound: { ... }   â† else åˆ†æ”¯ï¼ˆå¯é€‰ï¼‰
```

---

## ğŸ” ä¸‰ã€AST åœ¨å®é™…ä¸­çš„åº”ç”¨åœºæ™¯

### 1. é™æ€åˆ†æ & å®‰å…¨æ£€æµ‹
- æŸ¥æ‰¾å±é™©å‡½æ•°è°ƒç”¨ï¼ˆå¦‚ `gets`, `strcpy`ï¼‰
- æ£€æµ‹æœªåˆå§‹åŒ–å˜é‡ã€å†…å­˜æ³„æ¼æ¨¡å¼
- æ„å»ºæ§åˆ¶æµå›¾ï¼ˆCFGï¼‰è¿›è¡Œè·¯å¾„æ•æ„Ÿåˆ†æ

### 2. è‡ªåŠ¨é‡æ„ & ä»£ç è½¬æ¢
- è‡ªåŠ¨é‡å‘½åå˜é‡ï¼ˆéœ€ä½œç”¨åŸŸåˆ†æï¼‰
- æ’å…¥æ—¥å¿—ã€æ€§èƒ½ç›‘æ§ç‚¹
- å°† C ä»£ç è½¬æˆå…¶ä»–è¯­è¨€ï¼ˆå¦‚ Rustã€Pythonï¼‰

### 3. æ•™å­¦ & ç¨‹åºç†è§£
- å¯è§†åŒ–å±•ç¤ºä»£ç ç»“æ„
- å¸®åŠ©å­¦ç”Ÿç†è§£é€’å½’ã€ä½œç”¨åŸŸã€ç±»å‹ç³»ç»Ÿ
- æ”¯æŒ IDE çš„â€œè·³è½¬åˆ°å®šä¹‰â€ã€â€œæŸ¥æ‰¾å¼•ç”¨â€

### 4. ç¼–è¯‘å™¨ & è§£é‡Šå™¨å¼€å‘
- AST æ˜¯ IRï¼ˆIntermediate Representationï¼‰çš„ç¬¬ä¸€æ­¥
- åç»­å¯ç”Ÿæˆå­—èŠ‚ç ã€æœºå™¨ç ã€æˆ–åš SSA ä¼˜åŒ–

---

## âš ï¸ å››ã€å±€é™æ€§ä¸æ³¨æ„äº‹é¡¹

### 1. ä¸æ”¯æŒå…¨éƒ¨ C æ‰©å±•
- GCC ç‰¹æœ‰è¯­æ³•ï¼ˆå¦‚ `__attribute__`, å†…è”æ±‡ç¼–ï¼‰
- å®å±•å¼€éœ€é¢„å¤„ç†ï¼ˆå»ºè®®å…ˆç”¨ `gcc -E`ï¼‰

### 2. æ— è¯­ä¹‰åˆ†æ
- ç±»å‹æ£€æŸ¥ä¸å®Œæ•´ï¼ˆä»…è¯­æ³•å±‚é¢ï¼‰
- æ— æ³•è·¨æ–‡ä»¶è§£æç¬¦å·ï¼ˆæ— é“¾æ¥é˜¶æ®µï¼‰

### 3. AST â‰  CFG/DFG
- AST æ˜¯è¯­æ³•æ ‘ï¼ŒCFG æ˜¯æ§åˆ¶æµå›¾ï¼ŒDFG æ˜¯æ•°æ®æµå›¾
- éœ€é¢å¤–ç®—æ³•ä» AST æ„å»º CFGï¼ˆå¦‚éå† `If`, `While`, `Return`ï¼‰

---

## ğŸ“š äº”ã€å­¦ä¹ è·¯å¾„æ¨èï¼ˆç”±æµ…å…¥æ·±ï¼‰

### åˆçº§ â†’ ä¸­çº§
1. ä½¿ç”¨ `c_2_ast` å·¥å…·è§£æç®€å• C ç¨‹åºï¼Œè§‚å¯Ÿè¾“å‡ºç»“æ„
2. æ‰‹åŠ¨ç”»å‡º AST æ ‘ï¼ˆçº¸ç¬” or å·¥å…·å¦‚ Graphvizï¼‰
3. ä¿®æ”¹æºç ï¼Œå¯¹æ¯” AST å˜åŒ–ï¼ˆå¦‚åŠ å‡æ‹¬å·ã€æ¢è¿ç®—ç¬¦ï¼‰

### ä¸­çº§ â†’ é«˜çº§
4. ç¼–å†™ Python è„šæœ¬éå† ASTï¼ˆä½¿ç”¨ `pycparser` APIï¼‰
5. å®ç°ç®€å•çš„â€œæŸ¥æ‰¾æ‰€æœ‰å‡½æ•°è°ƒç”¨â€çš„åˆ†æå™¨
6. å°è¯•æ„å»ºç®€æ˜“ CFGï¼ˆè¯†åˆ«åŸºæœ¬å—ã€è·³è½¬è¾¹ï¼‰

### é«˜çº§ â†’ ä¸“å®¶
7. ç»“åˆ LLVM æˆ– Clang è¿›è¡Œæ›´æ·±å±‚æ¬¡çš„ IR åˆ†æ
8. å¼€å‘è‡ªå·±çš„ DSL å¹¶ä¸ºå…¶æ„å»º Parser + AST
9. ç ”ç©¶å­¦æœ¯è®ºæ–‡ï¼ˆå¦‚ PLDI, POPL ä¸­å…³äº AST-based analysis çš„å·¥ä½œï¼‰

---

## ğŸ› ï¸ å…­ã€åŠ¨æ‰‹å®éªŒå»ºè®®

ä½ å¯ä»¥ç«‹å³å°è¯•ä»¥ä¸‹æ“ä½œæ¥åŠ æ·±ç†è§£ï¼š

### ç¤ºä¾‹ 1ï¼šè§£æ Hello World
```c
// hello.c
#include <stdio.h>
int main() {
    printf("Hello, AST!\n");
    return 0;
}
```

æ‰§è¡Œï¼š
```bash
cd skills_for_all_agent/skill/c_2_ast/scripts/
python3 c_2_ast.py --input hello.c
```

è§‚å¯Ÿè¾“å‡ºä¸­ï¼š
- `FuncDef â†’ main`
- `FuncCall â†’ printf`
- `Constant â†’ string`
- `Return â†’ 0`

### ç¤ºä¾‹ 2ï¼šå¸¦æ¡ä»¶åˆ†æ”¯
```c
int max(int a, int b) {
    if (a > b) return a;
    else return b;
}
```

è§‚å¯Ÿï¼š
- `If` èŠ‚ç‚¹ç»“æ„
- `BinaryOp: >`
- ä¸¤ä¸ª `Return` åˆ†æ”¯

---

## ğŸ“˜ ä¸ƒã€å»¶ä¼¸é˜…è¯»æ¨è

- ğŸ“˜ ã€ŠEngineering a Compilerã€‹by Keith Cooper â€”â€” ç¬¬2ç« è¯¦è¿° AST
- ğŸ“˜ ã€ŠModern Compiler Implementation in Cã€‹by Andrew Appel
- ğŸŒ [pycparser æ–‡æ¡£](https://github.com/eliben/pycparser)
- ğŸŒ [AST Explorer](https://astexplorer.net/) â€”â€” åœ¨çº¿æŸ¥çœ‹ JS/Python/CSS çš„ AST
- ğŸ¥ YouTube: â€œHow compilers work: Abstract Syntax Treesâ€ by Jacob Sorber

---

## âœ… æ€»ç»“ï¼šAST æ˜¯ä»€ä¹ˆï¼Ÿ

> **AST æ˜¯ç¨‹åºçš„çµé­‚éª¨æ¶ â€”â€” å®ƒå‰¥ç¦»äº†è¡€è‚‰ï¼ˆæ ¼å¼ã€æ³¨é‡Šï¼‰ï¼Œåªç•™ä¸‹ç»“æ„ï¼ˆé€»è¾‘ã€å…³ç³»ï¼‰ã€‚æŒæ¡ ASTï¼Œä½ å°±æŒæ¡äº†ç¨‹åºçš„æœ¬è´¨å½¢æ€ã€‚**

æ— è®ºä½ æ˜¯æƒ³åšï¼š
- ç¼–è¯‘å™¨å·¥ç¨‹å¸ˆ ğŸ‘¨â€ğŸ’»
- å®‰å…¨ç ”ç©¶å‘˜ ğŸ”
- AI for Code ç ”ç©¶è€… ğŸ¤–
- æ•™è‚²å·¥ä½œè€… ğŸ§‘â€ğŸ«  
â†’ AST éƒ½æ˜¯ä½ å¿…é¡»ç²¾é€šçš„åŸºç¡€ï¼

---

å¦‚æœä½ æ„¿æ„ï¼Œæˆ‘å¯ä»¥ï¼š
1. ç»™ä½ ä¸€æ®µ C ä»£ç ï¼Œå¸¦ä½ ä¸€æ­¥æ­¥ç”»å‡ºå®ƒçš„ ASTï¼›
2. æ•™ä½ å¦‚ä½•ç”¨ Python éå†å’Œä¿®æ”¹ ASTï¼›
3. æ¼”ç¤ºå¦‚ä½•ä» AST è‡ªåŠ¨ç”Ÿæˆæ§åˆ¶æµå›¾ï¼ˆCFGï¼‰ï¼›
4. æä¾›ç»ƒä¹ é¢˜å’ŒæŒ‘æˆ˜ä»»åŠ¡ã€‚

ä½ æƒ³ä»å“ªä¸ªæ–¹å‘ç»§ç»­æ·±å…¥ï¼Ÿæ¬¢è¿å‘Šè¯‰æˆ‘ ğŸ˜Š

> Finished chain.

===== FINAL OUTPUT =====
ä½ å¸Œæœ›éå¸¸æ·±å…¥åœ°äº†è§£ **ASTï¼ˆAbstract Syntax Treeï¼ŒæŠ½è±¡è¯­æ³•æ ‘ï¼‰**ï¼Œè¿™æ˜¯ä¸€ä¸ªéå¸¸é‡è¦ä¸”åŸºç¡€çš„è®¡ç®—æœºç§‘å­¦æ¦‚å¿µï¼Œå°¤å…¶åœ¨ç¼–è¯‘å™¨è®¾è®¡ã€ç¨‹åºåˆ†æã€ä»£ç å®‰å…¨ã€é‡æ„å·¥å…·ç­‰é¢†åŸŸå…·æœ‰æ ¸å¿ƒåœ°ä½ã€‚

æ ¹æ®æˆ‘ä»¬ç›®å‰æ¢ç´¢åˆ°çš„å†…å®¹ï¼ˆç‰¹åˆ«æ˜¯ `c_2_ast` æŠ€èƒ½åŠå…¶é…å¥—çš„ `reference.md`ï¼‰ï¼Œæˆ‘å·²ç»ä¸ºä½ æ•´ç†äº†ä¸€ä»½**æ·±åº¦è§£æ AST çš„ç»“æ„åŒ–çŸ¥è¯†ä½“ç³»**ï¼Œæ¶µç›–ç†è®ºã€ç»“æ„ã€å®è·µå’Œåº”ç”¨ï¼š

---

## ğŸŒ² ä¸€ã€ä»€ä¹ˆæ˜¯ ASTï¼Ÿâ€”â€” æ ¸å¿ƒç†è®º

### 1. å®šä¹‰
**AST æ˜¯æºä»£ç è¯­æ³•ç»“æ„çš„æ ‘å½¢æŠ½è±¡è¡¨ç¤ºã€‚**
- å¿½ç•¥å…·ä½“å­—ç¬¦ï¼ˆå¦‚ç©ºæ ¼ã€æ³¨é‡Šã€åˆ†å·ï¼‰
- ä¿ç•™ç¨‹åºçš„**è¯­æ³•å±‚æ¬¡ä¸è¯­ä¹‰å…³ç³»**
- æ˜¯ç¼–è¯‘å™¨å‰ç«¯çš„æ ¸å¿ƒäº§ç‰©

### 2. ä¸ºä»€ä¹ˆéœ€è¦ ASTï¼Ÿ
- âœ… **ç»“æ„åŒ–è¡¨è¾¾**ï¼šå°†çº¿æ€§æ–‡æœ¬è½¬ä¸ºå¯éå†/åˆ†æçš„æ ‘
- âœ… **å¹³å°æ— å…³**ï¼šè„±ç¦»å…·ä½“ç¼–ç¨‹è¯­è¨€æ ¼å¼
- âœ… **ä¸­é—´è¡¨ç¤º**ï¼šç”¨äºåç»­ä¼˜åŒ–ã€è½¬æ¢ã€åˆ†æï¼ˆCFG/DFG/Vulnerability Detectionï¼‰
- âœ… **è‡ªåŠ¨åŒ–å¤„ç†**ï¼šæ”¯æŒé™æ€åˆ†æã€é‡æ„ã€ç¿»è¯‘ã€ç”Ÿæˆç­‰ä»»åŠ¡

### 3. AST vs Parse Tree
| ç‰¹æ€§ | Parse Tree (è¯­æ³•æ ‘) | AST (æŠ½è±¡è¯­æ³•æ ‘) |
|------|---------------------|------------------|
| åŒ…å«ç»†èŠ‚ | æ‰€æœ‰è¯­æ³•ç¬¦å·ï¼ˆæ‹¬å·ã€åˆ†å·ç­‰ï¼‰ | åªä¿ç•™å…³é”®ç»“æ„ |
| å±‚çº§æ·±åº¦ | æ›´æ·±ã€æ›´å†—ä½™ | æ›´æµ…ã€æ›´ç²¾ç®€ |
| åº”ç”¨åœºæ™¯ | è¯­æ³•æ•™å­¦ã€è°ƒè¯• | ç¼–è¯‘å™¨ã€åˆ†æå™¨ã€é‡æ„ |

> ğŸ’¡ AST æ˜¯ Parse Tree çš„â€œå‹ç¼©ç²¾åç‰ˆâ€

---

## ğŸ§± äºŒã€Cè¯­è¨€ AST ç»“æ„è¯¦è§£ï¼ˆåŸºäº `pycparser`ï¼‰

æˆ‘ä»¬ä½¿ç”¨çš„æŠ€èƒ½åº•å±‚ä¾èµ– [pycparser](https://github.com/eliben/pycparser)ï¼Œå®ƒæ”¯æŒ ISO C99 å­é›†ï¼Œè¾“å‡ºç»“æ„æ¸…æ™°ã€å±‚çº§æ˜ç¡®ã€‚

### 1. æ ¹èŠ‚ç‚¹ â€”â€” `FileAST`
ä»£è¡¨æ•´ä¸ªç¿»è¯‘å•å…ƒï¼ˆTranslation Unitï¼‰ï¼Œå³ä¸€ä¸ª `.c` æ–‡ä»¶ã€‚
```text
FileAST:
  FuncDef: main
  Decl: global_var
```

### 2. å‡½æ•°å®šä¹‰ â€”â€” `FuncDef`
```text
FuncDef:
  Decl: functionName
    TypeDecl: returnType
  ParamList: (å‚æ•°åˆ—è¡¨)
  Compound: {å‡½æ•°ä½“}
```

### 3. å£°æ˜èŠ‚ç‚¹ â€”â€” `Decl`
é€šç”¨å£°æ˜èŠ‚ç‚¹ï¼Œå¯ç”¨äºå˜é‡ã€å‡½æ•°ã€å‚æ•°ï¼š
```text
Decl: x
  TypeDecl: int
  init: Constant: 42
```

### 4. ç±»å‹ç³»ç»ŸèŠ‚ç‚¹
- `TypeDecl`: åŸºç¡€ç±»å‹ï¼ˆint, char...ï¼‰
- `PtrDecl`: æŒ‡é’ˆç±»å‹ `*`
- `ArrayDecl`: æ•°ç»„ç±»å‹ `[N]`
- `FuncDecl`: å‡½æ•°ç±»å‹ï¼ˆè¿”å›å€¼ + å‚æ•°ï¼‰

### 5. è¯­å¥å— â€”â€” `Compound`
å¯¹åº” `{}` åŒ…è£¹çš„å¤åˆè¯­å¥ï¼š
```text
Compound:
  Assignment
  If
  Return
```

### 6. è¡¨è¾¾å¼èŠ‚ç‚¹ï¼ˆé‡ç‚¹ï¼ï¼‰
#### â¤ `ID`: æ ‡è¯†ç¬¦å¼•ç”¨
```text
ID: variable_name
```

#### â¤ `Constant`: å­—é¢é‡
```text
Constant: int, 42
Constant: string, "hello"
```

#### â¤ `BinaryOp`: äºŒå…ƒæ“ä½œ
```text
BinaryOp: +
  ID: a
  ID: b
â†’ å¯¹åº” a + b
```

#### â¤ `FuncCall`: å‡½æ•°è°ƒç”¨
```text
FuncCall:
  ID: printf
  ExprList:
    Constant: string, "Hello"
â†’ å¯¹åº” printf("Hello");
```

#### â¤ `Assignment`: èµ‹å€¼è¯­å¥
```text
Assignment: =
  ID: x
  BinaryOp: *
    ID: y
    Constant: 2
â†’ å¯¹åº” x = y * 2;
```

#### â¤ `If / While / For`: æ§åˆ¶æµè¯­å¥
```text
If:
  BinaryOp: >
    ID: x
    Constant: 0
  Compound: { ... }   â† then åˆ†æ”¯
  Compound: { ... }   â† else åˆ†æ”¯ï¼ˆå¯é€‰ï¼‰
```

---

## ğŸ” ä¸‰ã€AST åœ¨å®é™…ä¸­çš„åº”ç”¨åœºæ™¯

### 1. é™æ€åˆ†æ & å®‰å…¨æ£€æµ‹
- æŸ¥æ‰¾å±é™©å‡½æ•°è°ƒç”¨ï¼ˆå¦‚ `gets`, `strcpy`ï¼‰
- æ£€æµ‹æœªåˆå§‹åŒ–å˜é‡ã€å†…å­˜æ³„æ¼æ¨¡å¼
- æ„å»ºæ§åˆ¶æµå›¾ï¼ˆCFGï¼‰è¿›è¡Œè·¯å¾„æ•æ„Ÿåˆ†æ

### 2. è‡ªåŠ¨é‡æ„ & ä»£ç è½¬æ¢
- è‡ªåŠ¨é‡å‘½åå˜é‡ï¼ˆéœ€ä½œç”¨åŸŸåˆ†æï¼‰
- æ’å…¥æ—¥å¿—ã€æ€§èƒ½ç›‘æ§ç‚¹
- å°† C ä»£ç è½¬æˆå…¶ä»–è¯­è¨€ï¼ˆå¦‚ Rustã€Pythonï¼‰

### 3. æ•™å­¦ & ç¨‹åºç†è§£
- å¯è§†åŒ–å±•ç¤ºä»£ç ç»“æ„
- å¸®åŠ©å­¦ç”Ÿç†è§£é€’å½’ã€ä½œç”¨åŸŸã€ç±»å‹ç³»ç»Ÿ
- æ”¯æŒ IDE çš„â€œè·³è½¬åˆ°å®šä¹‰â€ã€â€œæŸ¥æ‰¾å¼•ç”¨â€

### 4. ç¼–è¯‘å™¨ & è§£é‡Šå™¨å¼€å‘
- AST æ˜¯ IRï¼ˆIntermediate Representationï¼‰çš„ç¬¬ä¸€æ­¥
- åç»­å¯ç”Ÿæˆå­—èŠ‚ç ã€æœºå™¨ç ã€æˆ–åš SSA ä¼˜åŒ–

---

## âš ï¸ å››ã€å±€é™æ€§ä¸æ³¨æ„äº‹é¡¹

### 1. ä¸æ”¯æŒå…¨éƒ¨ C æ‰©å±•
- GCC ç‰¹æœ‰è¯­æ³•ï¼ˆå¦‚ `__attribute__`, å†…è”æ±‡ç¼–ï¼‰
- å®å±•å¼€éœ€é¢„å¤„ç†ï¼ˆå»ºè®®å…ˆç”¨ `gcc -E`ï¼‰

### 2. æ— è¯­ä¹‰åˆ†æ
- ç±»å‹æ£€æŸ¥ä¸å®Œæ•´ï¼ˆä»…è¯­æ³•å±‚é¢ï¼‰
- æ— æ³•è·¨æ–‡ä»¶è§£æç¬¦å·ï¼ˆæ— é“¾æ¥é˜¶æ®µï¼‰

### 3. AST â‰  CFG/DFG
- AST æ˜¯è¯­æ³•æ ‘ï¼ŒCFG æ˜¯æ§åˆ¶æµå›¾ï¼ŒDFG æ˜¯æ•°æ®æµå›¾
- éœ€é¢å¤–ç®—æ³•ä» AST æ„å»º CFGï¼ˆå¦‚éå† `If`, `While`, `Return`ï¼‰

---

## ğŸ“š äº”ã€å­¦ä¹ è·¯å¾„æ¨èï¼ˆç”±æµ…å…¥æ·±ï¼‰

### åˆçº§ â†’ ä¸­çº§
1. ä½¿ç”¨ `c_2_ast` å·¥å…·è§£æç®€å• C ç¨‹åºï¼Œè§‚å¯Ÿè¾“å‡ºç»“æ„
2. æ‰‹åŠ¨ç”»å‡º AST æ ‘ï¼ˆçº¸ç¬” or å·¥å…·å¦‚ Graphvizï¼‰
3. ä¿®æ”¹æºç ï¼Œå¯¹æ¯” AST å˜åŒ–ï¼ˆå¦‚åŠ å‡æ‹¬å·ã€æ¢è¿ç®—ç¬¦ï¼‰

### ä¸­çº§ â†’ é«˜çº§
4. ç¼–å†™ Python è„šæœ¬éå† ASTï¼ˆä½¿ç”¨ `pycparser` APIï¼‰
5. å®ç°ç®€å•çš„â€œæŸ¥æ‰¾æ‰€æœ‰å‡½æ•°è°ƒç”¨â€çš„åˆ†æå™¨
6. å°è¯•æ„å»ºç®€æ˜“ CFGï¼ˆè¯†åˆ«åŸºæœ¬å—ã€è·³è½¬è¾¹ï¼‰

### é«˜çº§ â†’ ä¸“å®¶
7. ç»“åˆ LLVM æˆ– Clang è¿›è¡Œæ›´æ·±å±‚æ¬¡çš„ IR åˆ†æ
8. å¼€å‘è‡ªå·±çš„ DSL å¹¶ä¸ºå…¶æ„å»º Parser + AST
9. ç ”ç©¶å­¦æœ¯è®ºæ–‡ï¼ˆå¦‚ PLDI, POPL ä¸­å…³äº AST-based analysis çš„å·¥ä½œï¼‰

---

## ğŸ› ï¸ å…­ã€åŠ¨æ‰‹å®éªŒå»ºè®®

ä½ å¯ä»¥ç«‹å³å°è¯•ä»¥ä¸‹æ“ä½œæ¥åŠ æ·±ç†è§£ï¼š

### ç¤ºä¾‹ 1ï¼šè§£æ Hello World
```c
// hello.c
#include <stdio.h>
int main() {
    printf("Hello, AST!\n");
    return 0;
}
```

æ‰§è¡Œï¼š
```bash
cd skills_for_all_agent/skill/c_2_ast/scripts/
python3 c_2_ast.py --input hello.c
```

è§‚å¯Ÿè¾“å‡ºä¸­ï¼š
- `FuncDef â†’ main`
- `FuncCall â†’ printf`
- `Constant â†’ string`
- `Return â†’ 0`

### ç¤ºä¾‹ 2ï¼šå¸¦æ¡ä»¶åˆ†æ”¯
```c
int max(int a, int b) {
    if (a > b) return a;
    else return b;
}
```

è§‚å¯Ÿï¼š
- `If` èŠ‚ç‚¹ç»“æ„
- `BinaryOp: >`
- ä¸¤ä¸ª `Return` åˆ†æ”¯

---

## ğŸ“˜ ä¸ƒã€å»¶ä¼¸é˜…è¯»æ¨è

- ğŸ“˜ ã€ŠEngineering a Compilerã€‹by Keith Cooper â€”â€” ç¬¬2ç« è¯¦è¿° AST
- ğŸ“˜ ã€ŠModern Compiler Implementation in Cã€‹by Andrew Appel
- ğŸŒ [pycparser æ–‡æ¡£](https://github.com/eliben/pycparser)
- ğŸŒ [AST Explorer](https://astexplorer.net/) â€”â€” åœ¨çº¿æŸ¥çœ‹ JS/Python/CSS çš„ AST
- ğŸ¥ YouTube: â€œHow compilers work: Abstract Syntax Treesâ€ by Jacob Sorber

---

## âœ… æ€»ç»“ï¼šAST æ˜¯ä»€ä¹ˆï¼Ÿ

> **AST æ˜¯ç¨‹åºçš„çµé­‚éª¨æ¶ â€”â€” å®ƒå‰¥ç¦»äº†è¡€è‚‰ï¼ˆæ ¼å¼ã€æ³¨é‡Šï¼‰ï¼Œåªç•™ä¸‹ç»“æ„ï¼ˆé€»è¾‘ã€å…³ç³»ï¼‰ã€‚æŒæ¡ ASTï¼Œä½ å°±æŒæ¡äº†ç¨‹åºçš„æœ¬è´¨å½¢æ€ã€‚**

æ— è®ºä½ æ˜¯æƒ³åšï¼š
- ç¼–è¯‘å™¨å·¥ç¨‹å¸ˆ ğŸ‘¨â€ğŸ’»
- å®‰å…¨ç ”ç©¶å‘˜ ğŸ”
- AI for Code ç ”ç©¶è€… ğŸ¤–
- æ•™è‚²å·¥ä½œè€… ğŸ§‘â€ğŸ«  
â†’ AST éƒ½æ˜¯ä½ å¿…é¡»ç²¾é€šçš„åŸºç¡€ï¼

---

å¦‚æœä½ æ„¿æ„ï¼Œæˆ‘å¯ä»¥ï¼š
1. ç»™ä½ ä¸€æ®µ C ä»£ç ï¼Œå¸¦ä½ ä¸€æ­¥æ­¥ç”»å‡ºå®ƒçš„ ASTï¼›
2. æ•™ä½ å¦‚ä½•ç”¨ Python éå†å’Œä¿®æ”¹ ASTï¼›
3. æ¼”ç¤ºå¦‚ä½•ä» AST è‡ªåŠ¨ç”Ÿæˆæ§åˆ¶æµå›¾ï¼ˆCFGï¼‰ï¼›
4. æä¾›ç»ƒä¹ é¢˜å’ŒæŒ‘æˆ˜ä»»åŠ¡ã€‚

ä½ æƒ³ä»å“ªä¸ªæ–¹å‘ç»§ç»­æ·±å…¥ï¼Ÿæ¬¢è¿å‘Šè¯‰æˆ‘ ğŸ˜Š